# **4 IO 管理**

我们之前了解过了 Linux 的进程和线程、Linux 内存管理，那么下面我们就来认识一下 Linux 中的 I/O 管理。

Linux 系统和其他 UNIX 系统一样，IO 管理比较直接和简洁。所有 IO 设备都被当作文件，通过在系统内部使用相同的 read 和 write 一样进行读写。

## **4.1 Linux IO 基本概念**

Linux 中也有磁盘、打印机、网络等 I/O 设备，Linux 把这些设备当作一种 特殊文件 整合到文件系统中，一般通常位于 /dev 目录下。可以使用与普通文件相同的方式来对待这些特殊文件。

特殊文件一般分为两种：

块特殊文件是一个能存储 固定大小块 信息的设备，它支持 以固定大小的块，扇区或群集读取和（可选）写入数据。每个块都有自己的 物理地址。通常块的大小在 512 - 65536 之间。所有传输的信息都会以 连续 的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 硬盘、蓝光光盘、USB 盘与字符设备相比，块设备通常需要较少的引脚。

![块设备](https://github.com/looken/leetbook/blob/main/awesome-linux-handbook/images/io1.png?raw=true)

块特殊文件的缺点基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。

另一类 I/O 设备是 字符特殊文件。字符设备以 字符 为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。

![字符设备](https://github.com/looken/leetbook/blob/main/awesome-linux-handbook/images/io2.png?raw=true)

每个设备特殊文件都会和 设备驱动 相关联。每个驱动程序都通过一个 主设备号 来标识。如果一个驱动支持多个设备的话，此时会在主设备的后面新加一个 次设备号 来标识。主设备号和次设备号共同确定了唯一的驱动设备。

我们知道，在计算机系统中，CPU 并不直接和设备打交道，它们中间有一个叫作 设备控制器（Device Control Unit）的组件，例如硬盘有磁盘控制器、USB 有 USB 控制器、显示器有视频控制器等。这些控制器就像代理商一样，它们知道如何应对硬盘、鼠标、键盘、显示器的行为。

绝大多数字符特殊文件都不能随机访问，因为他们需要使用和块特殊文件不同的方式来控制。比如，你在键盘上输入了一些字符，但是你发现输错了一个，这时有一些人喜欢使用 backspace 来删除，有人喜欢用 del 来删除。为了中断正在运行的设备，一些系统使用 ctrl-u 来结束，但是现在一般使用 ctrl-c 来结束。

## **4.2 网络**

I/O 的另外一个概念是 网络， 也是由 UNIX 引入，网络中一个很关键的概念就是 套接字(socket)。套接字允许用户连接到网络，正如邮筒允许用户连接到邮政系统，套接字的示意图如下

![套接字](https://github.com/looken/leetbook/blob/main/awesome-linux-handbook/images/io3.png?raw=true)

套接字的位置如上图所示，套接字可以动态创建和销毁。成功创建一个套接字后，系统会返回一个 文件描述符(file descriptor)，在后面的创建链接、读数据、写数据、解除连接时都需要使用到这个文件描述符。每个套接字都支持一种特定类型的网络类型，在创建时指定。一般最常用的几种

* 可靠的面向连接的字节流
* 可靠的面向连接的数据包
* 不可靠的数据包传输
* 可靠的面向连接的字节流会使用 管道 在两台机器之间建立连接。能够保证字节从一台机器按照顺序到达另一台机器，系统能够保证所有字节都能到达。

除了数据包之间的分界之外，第二种类型和第一种类型是类似的。如果发送了 3 次写操作，那么使用第一种方式的接受者会直接接收到所有字节；第二种方式的接受者会分 3 次接受所有字节。除此之外，用户还可以使用第三种即不可靠的数据包来传输，使用这种传输方式的优点在于高性能，有的时候它比可靠性更加重要，比如在流媒体中，性能就尤其重要。

![网络协议分层](https://github.com/looken/leetbook/blob/main/awesome-linux-handbook/images/io4.png?raw=true)

以上涉及两种形式的传输协议，即 TCP 和 UDP，TCP 是 传输控制协议，它能够传输可靠的字节流。UDP 是 用户数据报协议，它只能够传输不可靠的字节流。它们都属于 TCP/IP 协议簇中的协议，下面是网络协议分层

可以看到，TCP 、UDP 都位于网络层上，可见它们都把 IP 协议 即 互联网协议 作为基础。

一旦套接字在源计算机和目的计算机建立成功，那么两个计算机之间就可以建立一个链接。通信一方在本地套接字上使用 listen 系统调用，它就会创建一个缓冲区，然后阻塞直到数据到来。另一方使用 connect 系统调用，如果另一方接受 connect 系统调用后，则系统会在两个套接字之间建立连接。

socket 连接建立成功后就像是一个管道，一个进程可以使用本地套接字的文件描述符从中读写数据，当连接不再需要的时候使用 close 系统调用来关闭。


## **4.3 Linux I/O 系统调用**

Linux 系统中的每个 I/O 设备都有一个 特殊文件(special file) 与之关联，什么是特殊文件呢？

> 在操作系统中，特殊文件是一种在文件系统中与硬件设备相关联的文件。特殊文件也被称为 设备文件(device file)。特殊文件的目的是将设备作为文件系统中的文件进行公开。特殊文件为硬件设备提供了借口，用于文件 I/O 的工具可以进行访问。因为设备有两种类型，同样特殊文件也有两种，即字符特殊文件和块特殊文件

对于大部分 I/O 操作来说，只用合适的文件就可以完成，并不需要特殊的系统调用。然后，有时需要一些设备专用的处理。在 POSIX 之前，大多数 UNIX 系统会有一个叫做 ioctl 的系统调用，它用于执行大量的系统调用。随着时间的发展，POSIX 对其进行了整理，把 ioctl 的功能划分为面向终端设备的独立功能调用，现在已经变成独立的系统调用了。

下面是几个管理终端的系统调用

|  系统调用   | 描述  |
|  ----  | ----  |
|  tcgetattr  |	获取属性 |
|  tcsetattr  |	设置属性 |
|  cfgetispeed  |	获取输入速率 |
|  cfgetospeed  |	获取输出速率 |
|  cfsetispeed  |	设置输入速率 |
|  cfsetospeed  |	设置输出速率 |

## **4.4 Linux IO 实现**

Linux 中的 IO 是通过一系列设备驱动实现的，每个设备类型对应一个设备驱动。设备驱动为操作系统和硬件分别预留接口，通过设备驱动来屏蔽操作系统和硬件的差异。

当用户访问一个特殊的文件时，由文件系统提供此特殊文件的主设备号和次设备号，并判断它是一个块特殊文件还是字符特殊文件。主设备号用于标识字符设备还是块设备，次设备号用于参数传递。

每个 驱动程序 都有两部分：这两部分都是属于 Linux 内核，也都运行在内核态下。上半部分运行在调用者上下文并且与 Linux 其他部分交互。下半部分运行在内核上下文并且与设备进行交互。驱动程序可以调用内存分配、定时器管理、DMA 控制等内核过程。可被调用的内核功能都位于 驱动程序 - 内核接口 的文档中。

I/O 实现指的就是对字符设备和块设备的实现


### **4.4.1 块设备实现**

系统中处理块特殊文件 I/O 部分的目标是为了使传输次数尽可能的小。为了实现这个目标，Linux 系统在磁盘驱动程序和文件系统之间设置了一个 高速缓存(cache) ，如下图所示

![高速缓存](https://github.com/looken/leetbook/blob/main/awesome-linux-handbook/images/io5.png?raw=true)

在 Linux 内核 2.2 之前，Linux 系统维护着两个缓存：页面缓存(page cache) 和 缓冲区缓存(buffer cache)，因此，存储在一个磁盘块中的文件可能会在两个缓存中。2.2 版本以后 Linux 内核只有一个统一的缓存一个 通用数据块层(generic block layer) 把这些融合在一起，实现了磁盘、数据块、缓冲区和数据页之间必要的转换。那么什么是通用数据块层？

> 通用数据块层是一个内核的组成部分，用于处理对系统中所有块设备的请求。通用数据块主要有以下几个功能
> 将数据缓冲区放在内存高位处，当 CPU 访问数据时，页面才会映射到内核线性地址中，并且此后取消映射
> 实现 零拷贝机制，磁盘数据可以直接放入用户模式的地址空间，而无需先复制到内核内存中
> 管理磁盘卷，会把不同块设备上的多个磁盘分区视为一个分区。
> 利用最新的磁盘控制器的高级功能，例如 DMA 等。

cache 是提升性能的利器，不管以什么样的目的需要一个数据块，都会先从 cache 中查找，如果找到直接返回，避免一次磁盘访问，能够极大的提升系统性能。

如果页面 cache 中没有这个块，操作系统就会把页面从磁盘中调入内存，然后读入 cache 进行缓存。

cache 除了支持读操作外，也支持写操作，一个程序要写回一个块，首先把它写到 cache 中，而不是直接写入到磁盘中，等到磁盘中缓存达到一定数量值时再被写入到 cache 中。

Linux 系统中使用 IO 调度器 来保证减少磁头的反复移动从而减少损失。I/O 调度器的作用是对块设备的读写操作进行排序，对读写请求进行合并。Linux 有许多调度器的变体，从而满足不同的工作需要。最基本的 Linux 调度器是基于传统的 Linux 电梯调度器(Linux elevator scheduler)。Linux 电梯调度器的主要工作流程就是按照磁盘扇区的地址排序并存储在一个 双向链表 中。新的请求将会以链表的形式插入。这种方法可以有效的防止磁头重复移动。因为电梯调度器会容易产生饥饿现象。因此，Linux 在原基础上进行了修改，维护了两个链表，在 最后日期(deadline) 内维护了排序后的读写操作。默认的读操作耗时 0.5s，默认写操作耗时 5s。如果在最后期限内等待时间最长的链表没有获得服务，那么它将优先获得服务。

### **4.4.2 字符设备实现**

和字符设备的交互是比较简单的。由于字符设备会产生并使用字符流、字节数据，因此对随机访问的支持意义不大。一个例外是使用 行规则(line disciplines)。一个行规可以和终端设备相关联，使用 tty_struct 结构来表示，它表示与终端设备交换数据的解释器，当然这也属于内核的一部分。例如：行规可以对行进行编辑，映射回车为换行等一系列其他操作。

> 什么是行规则？
> 行规是某些类 UNIX 系统中的一层，终端子系统通常由三层组成：上层提供字符设备接口，下层硬件驱动程序与硬件或伪终端进行交互，中层规则用于实现终端设备共有的行为。

![行规则](https://github.com/looken/leetbook/blob/main/awesome-linux-handbook/images/io6.png?raw=true)

### **4.4.3 网络设备实现**

网络设备的交互是不一样的，虽然 网络设备(network devices) 也会产生字符流，因为它们的 异步(asynchronous) 特性是他们不易与其他字符设备在同一接口下集成。网络设备驱动程序会产生很多数据包，经由网络协议到达用户应用程序中。

## **4.5 Linux 中的模块**

UNIX 设备驱动程序是被 静态加载 到内核中的。因此，只要系统启动后，设备驱动程序都会被加载到内存中。随着个人电脑 Linux 的出现，这种静态链接完成后会使用一段时间的模式被打破。相对于小型机上的 I/O 设备，PC 上可用的 I/O 设备有了数量级的增长。绝大多数用户没有能力去添加一个新的应用程序、更新设备驱动、重新连接内核，然后进行安装。

Linux 为了解决这个问题，引入了 可加载(loadable module) 机制。可加载是在系统运行时添加到内核中的代码块。

当一个模块被加载到内核时，会发生下面几件事情：第一，在加载的过程中，模块会被动态的重新部署。第二，系统会检查程序程序所需的资源是否可用。如果可用，则把这些资源标记为正在使用。第三步，设置所需的中断向量。第四，更新驱动转换表使其能够处理新的主设备类型。最后再来运行设备驱动程序。

在完成上述工作后，驱动程序就会安装完成，其他现代 UNIX 系统也支持可加载机制。

