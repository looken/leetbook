# **1 编译内存相关**

本章是 C++ 面经的开章之作，其中涉及 C++ 程序的编译过程、内存以及头文件的一些知识点，重点在内存方面进行展开，包括内存的分区、内存对齐、内存泄漏、内存泄漏的防止方法、现有的检测内存泄漏的工具等等。由于问题之间的关联性，可能有些问题并非是本章相关的知识点，例如一些问题涉及到了类中的虚函数、创建类的对象的底层原理等等，但为了保持问题上下的连贯性，也放在了本章，便于问题的理解。

## **1.1 C++ 程序编译过程**
> 面试高频指数：★★★★☆

编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。
* 编译预处理：处理以 # 开头的指令；
* 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；
* 汇编：将汇编代码 .s 翻译成机器指令 .o 文件；
* 链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

![编译过程](https://github.com/looken/leetbook/blob/main/1612676946-HVvkdR-image.png?raw=true)

链接分为两种：

* 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。
* 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

二者的优缺点：

* 静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
* 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。


## **1.2 C++ 内存管理**
> 面试高频指数：★★★★★

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

* 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
* 堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
* 常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。
* 代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。
说明：
* 从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env

程序实例：
```cpp
#include <iostream>
using namespace std;

/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/

int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```

## **1.3 栈和堆的区别**
## **1.4 变量的区别**
## **1.5 全局变量定义在头文件中有什么问题？**
## **1.6 对象创建限制在堆或栈**
## **1.7 内存对齐**
## **1.8 类的大小**
## **1.9 什么是内存泄露**
## **1.10 怎么防止内存泄漏？内存泄漏检测工具的原理？**
## **1.11 智能指针有哪几种？智能指针的实现原理？**
## **1.12 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？**
## **1.13 使用智能指针会出现什么问题？怎么解决？**




